= slide 'Въпрос 1' do

  example:
    elements = (1, 'larodi', 42),
    for element in elements:
      print(element)
  p.action (1, 'larodi', 42)

= slide 'Въпрос 2' do
  example:
    {x+y for x in range(3) for y in range(3)}
  p.action {0, 1, 2, 3, 4}

= slide 'Въпрос 3' do
  example:
    keys = [1, 2, 3]
    keys.append([4, 5, 6])
    {key: "Panda" for key in keys}
  p.action TypeError: unhashable type: 'list'

= slide 'Въпрос 4' do
  example:
    len(x ** 2 for x in range(5))
  p.action TypeError: object of type 'generator' has no len()

= slide 'Въпрос 5' do
  example:
    {1, 2, 3, 3, 3, 4, 5}.count(3)
  p.action AttributeError: 'set' object has no attribute 'count'

= slide 'OOP' do
  p Обектно-ориентирано програмиране

= slide 'От идейна гледна точка' do
  p Разбирайте „за програмирането генерално“
  ol
    li Абстракция
    li Енкапсулация
    li Модулярност

= slide 'Абстракция' do
  p Най-общо казано(демек, според википедия):
  blockquote cite='http://en.wikipedia.org/wiki/Abstraction' Abstraction in its main sense is a conceptual process by which general rules and concepts are derived from the usage and classification of specific examples, literal ("real" or "concrete") signifiers, first principles, or other methods. "An abstraction" is the product of this process—a concept that acts as a super-categorical noun for all subordinate concepts, and connects any related concepts as a group, field, or category.

= slide 'Абстракция' do
  p А по-конкретно за областта, която ни интересува
  blockquote cite='http://en.wikipedia.org/wiki/Abstraction_(computer_science)' […] a technique for managing complexity of computer systems. It works by establishing a level of complexity on which a person interacts with the system, suppressing the more complex details below the current level. The programmer works with an idealized interface (usually well defined) and can add additional levels of functionality that would otherwise be too complex to handle.

= slide 'Абстракция' do
  img src='3/abstraction.png'


= slide 'Енкапсулация' do
  blockquote cite='http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)' Encapsulation is the packing of data and functions into a single component.

  p Има много механизми, с които можем да го реализираме, но обектно-ориентираното програмиране е един от най-популярните

= slide 'Information hiding' do
  blockquote cite='http://stackoverflow.com/a/24748' Abstraction and encapsulation are complementary concepts: abstraction focuses on the observable behavior of an object... encapsulation focuses upon the implementation that gives rise to this behavior... encapsulation is most often achieved through information hiding, which is the process of hiding all of the secrets of object that do not contribute to its essential characteristics.

= slide 'Модулярност' do
  p Механизъм за организиране на сходна логика, работеща върху свързани видове данни, обработваща сходни видове процеси от моделирания свят, в добре обособени и ясно разделени парчета от кода ни

= slide 'По същество' do
  p Разбирайте „конкретно за python“
  ol
    li Всичко е обект
    li Обектите са отворени
    li Класовете са отворение

  p Последните две с някои малки уговорки, които обаче рядко ще ви интересуват

= slide 'Всичко е обект' do
  p Съвсем буквално
  example:
    >>> type(42)
    <class 'int'>
    >>> type([])
    <class 'list'>
    >>> type([]) is list
    True
    >>> type(list)
    <class 'type'>
    >>> type(list) is type
    True

= slide 'Тогава…' do
  example:
    >>> type(type)

  p ???
  p.action &lt;class 'type'&gt;

  img.action src='3/mind_blown.gif'

= slide 'Класове' do
  p Създаваме класове с ключовата дума <code>class</code>, след което всяка функция, дефинирана в тялото на класа, е метод, а всяка променлива е клас променлива

= slide 'Примерен клас Vector' do
  example:
    class Vector:
        def __init__(self, x, y):
            self.x = x
            self.y = y

    spam = Vector(1.0, 1.0)
    print(spam.x)

  ol.action
    li „Конструктурът“ се казва <code>__init__</code>, той не връща стойност
    li Първият аргумент на методите винаги е инстанцията, върху която се извикват, той може да се казва всякак, но винаги се казва <code>self</code> , иначе губите огромни количества точки/колегите ви ви мразят/никой не иска да си играе с вас в пясъчника
    li Атрибутите („член-променливите“/„член-данните“) не се нуждаят от декларации (обектите са отворени)
    li Инстанцираме клас, като го „извикаме“ със съответните аргументи, които очаква <code>__init__</code>   методът му и като резултат получаваме новоконструирания обект

= slide 'Забележки' do
  p „Конструктор“ е думата, с която сте свикнали, но в случая далеч по-подходяща е „инициализатор“, както си личи от името

  p Въпреки че при инстанциране на обект подаваме аргументите, които очаква инициализаторът, той не е първият метод, който се извиква в този момент, но засега не влагайте много мисъл в това, просто го имайте предвид

= slide 'Примерен клас Vector (2)' do
  example:
    import math


    class Vector:
        def __init__(self, x, y): ...

        def length(self):
            return math.sqrt(self.x**2 + self.y**2)

        spam = Vector(1.0, 2.0)
        print(spam.length())

  ol.action
    li В методите атрибутите могат да се достъпват само през <code>self</code> , няма никакви магически имплицитни scope-ове
    li Методите се извикват през инстанцирания обект <code>обект.име_на_метод()</code>

= slide 'Примерен клас Vector (3)' do
  example:
    class Vector:
        def __init__(self, x, y, z): ...

        def _coords(self):
            return (self.x, self.y, self.z)

        def length(self):
            return sum(_ ** 2 for _ in self._coords()) ** 0.5

  ol.action
    li _coords е protected метод
    li Отново, методите се извикват върху self
    li _ е валидно име за променлива


= slide 'Private/protected' do
  p Казахме, че класовете са отворени. Това ще рече, че private и protected концепциите не са това, за което сте свикнали да мислите в езици като C++/Java/C#

  p Ограниченията за използване на защитени и частни методи в класовете в python са отговорност на програмиста, което по никакъв начин не прави живота ви по-труден

  p Методи/атрибути, започващи с _, са защитени, т.е. би следвало да се ползват само от методи на класа и наследяващи го класове

  p Методи/атрибути, започващи с __, са частни, т.е. би следвало да се ползват само от методи на класа

  p Достатъчно очевидно е, а в някои много редки случаи може да се наложи тези ограничения да не се спазят

= slide 'unbound methods' do
  example:
    v1 = Vector(1.0, 2.0, 3.0)
    v2 = Vector(4.0, 5.0, 6.0)
    v3 = Vector(7.0, 8.0, 9.0)

    print(Vector.length(v1))
    print(Vector.length(v2))


  p Което може да бъде полезно за следното
  example:
    print(list(map(Vector.length, [v1, v2, v3])))


= slide 'Състояние' do
  p Mutable vs. Immutable

  ul
    li mutable са обекти, които променят вътрешното си състояние във времето
    li immutable са обекти, които никога не променят вътрешното си състояние

  p Най-общо, повечето обекти в python са mutable, доколкото езикът не ни забранява да ги променяме

  p.action Какво в python знаем, че е immutable?

= slide 'mutating method' do
  example:
    class Vector:
        def __init__(self, x, y, z): ...

        def length(self): ...

        def normalize(self):
            length = self.length()
            self.x /= length
            self.y /= length
            self.z /= length


= slide 'non-mutating method' do
  example:
    class Vector:
        def __init__(self, x, y, z): ...

        def length(self): ...

        def normalized(self):
            length = self.length()
            return Vector(self.x / length,
                          self.y / length, self.z / length)


= slide 'normalize vs. normalized' do
  example:
    class Vector:
        ...

        def normalize(self):
            length = self.length()
            self.x /= length
            self.y /= length
            self.z /= length

        def normalized(self):
            return Vector(self.x / self.length(), self.y / self.length(),
                          self.z / self.length())


= slide 'Сравняване на обекти' do
  ul
    li Можете да проверите дали два обекта са равни по стойност с ==
    li Можете да проверите дали две имена сочат към един и същ обект с is
    li Можете да предефинирате равенството за обекти от даден клас с метода __eq__
    li По подразбиране, __eq__ е имплементиран с is

    example:
      class Vector:
          def __init__(self, x, y, z):
              self._coords = (x, y, z)

          def __eq__(self, other):
              return self._coords == other._coords

= slide 'dunder methods' do
  p Известни още като "magic methods", dunder(double under) методите в python най-често предефинират някакъв аспект от поведението на обектите ни

= slide 'Аритметични оператори' do
  ul
    li <code>__add__(self, other)</code> - <code>self + other</code>
    li <code>__sub__(self, other)</code> - <code>self - other</code>
    li <code>__mul__(self, other)</code> - <code>self * other</code>
    li <code>__truediv__(self, other)</code> - <code>self / other</code>
    li <code>__floordiv__(self, other)</code> - <code>self // other</code>
    li <code>__mod__(self, other)</code> - <code>self % other</code>
    li <code>__lshift__(self, other)</code> - <code>self << other</code>
    li <code>__rshift__(self, other)</code> - <code>self >> other</code>
    li <code>__and__(self, other)</code> - <code>self & other</code>
    li <code>__xor__(self, other)</code> - <code>self ^ other</code>
    li <code>__or__(self, other)</code> - <code>self | other</code>


= slide 'Преобразуване до стандартни типове' do
  ul
    li <code>__int__(self)</code> - <code>int(обект)</code>
    li <code>__float__(self)</code> - <code>float(обект)</code>
    li <code>__complex__(self)</code> - <code>complex(обект)</code>
    li <code>__bool__(self)</code> - <code>bool(обект)</code>


= slide 'Обекти, които могат да бъдат извиквани като функции' do
  p Можете да дефинирате поведение на обектите си, когато биват извиквани като функции
  example:
    class Stamp:
      def __init__(self, name):
          self.name = name

      def __call__(self, something):
          print("{0} was stamped by {1}".format(something, self.name))

    >>> stamp = Stamp("The government")
    >>> stamp("That thing there")
    That thing there was stamped by The government

= slide 'getattr/setattr' do
  p Можем да достъпваме/променяме атрибути на обект динамично

  example:
    >>> v1 = Vector(1, 1, 1)
    >>> getattr(v1, 'y')
    1
    >>> setattr(v1, 'z', 5)
    >>> getattr(v1, 'z')
    5


= slide 'Статични методи' do
  p Можете да дефинирате методи, така че те да са статични - т.е. да нямат нужда от инстанция
  example:
    class GoatSimulator:
        goats = []

        @staticmethod
        def register(name):
            GoatSimulator.goats.append(name)
            print(len(GoatSimulator.goats), " goats are registered now")

    >>> GoatSimulator.register("Pip the Happy Goat")
    1 goats are registered now
    >>> GoatSimulator.register("George the Gutsy Goat")
    2 goats are registered now


= slide 'Класови методи' do
  p Можете да използвате и @classmethod, за да получите класа, от който е извикан методът като първи аргумент
  example:
    class Countable:
        _count = 0

        def __init__(self, data):
            self.data = data
            type(self).increase_count()

        @classmethod
        def increase_count(cls):
            cls._count += 1

        @classmethod
        def decrease_count(cls):
            cls._count -= 1

= slide '"Деструктор"' do
  p Когато обект от даден тип бъде събран от garbage collector-а, се извиква неговият <code>__del__</code> метод.
  p Той не прави това, което прави деструкторът в C++, а неща от по-високо ниво, например затваря мрежови връзки или файлове, изпраща съобщения до някъде, че нещо е приключило и прочее.

  example:
    class Countable:
        _count = 0

        def __init__(self, data):
            self.data = data
            type(self).increase_count()

        @classmethod
        def increase_count(cls):
            cls._count += 1

        @classmethod
        def decrease_count(cls):
            cls._count -= 1

        def __del__(self):
            type(self).decrease_count()
