/ lists, dicts, sets, comprehensions, ranges, EXAMPLES

= slide 'Въпрос' do
    annotate:
        def my_func(a, b='66'):
            print('{}'.format(a) + b*a)
    p Какво ще видим, ако изпълним следното:
    annotate:
        >> print(my_func(6))

    p   
        annotate.action
            |6666666666666
        |<br/>
        annotate.action
            |None

= slide 'Още един:' do
    annotate:
        my_string = '1234567890'
        >>a[10]
    p.action  IndexError: string index out of range

= slide 'И още един..' do
    annotate:
        my_data = set(range(10))

        for x in my_data:
            print(x)
            break

    p.action Ще изпринти един от елементите, без гаранция кой

= slide 'Последен..' do 
    annotate:
        {}
        set()
        1
        None
        True
        [1, 2, 3]
        (1, 2, 3)
        12.0
        'абвг'
        lambda x: x**0
        print, 5, 6, 7, 8

    p.action Кои от тези са валидни ключове за dict?

    p.action 1, None, True, (1, 2, 3), 12.0, 'абвг', lambda-та и (print, 5, 6, 7 ,8)

= slide 'Излъгах :)' do
    annotate:
        my_dict = dict('12 34 16'.split() + [(False, False)]
        print(len(c), c[0])


    p.action 3 False
= slide 'Написахте ли си домашното?' do
    div style="font-size: 20px; line-height: 125%"
        div ░░░░░░░░░▄░░░░░░░░░░░░░░▄░░░░
        div ░░░░░░░░▌▒█░░░░░░░░░░░▄▀▒▌░░░
        div ░░░░░░░░▌▒▒█░░░░░░░░▄▀▒▒▒▐░░░
        div ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐░░░
        div ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐░░░
        div ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌░░░
        div ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒▌░░
        div ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐░░
        div ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄▌░
        div ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒▌░
        div ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒▐░
        div ▐▒▒▐▀▐▀▒░▄▄▒▄▒▒▒▒▒▒░▒░▒░▒▒▒▒▌
        div ▐▒▒▒▀▀▄▄▒▒▒▄▒▒▒▒▒▒▒▒░▒░▒░▒▒▐░
        div ░▌▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒░▒░▒░▒░▒▒▒▌░
        div ░▐▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒░▒░▒▒▄▒▒▐░░
        div ░░▀▄▒▒▒▒▒▒▒▒▒▒▒░▒░▒░▒▄▒▒▒▒▌░░
        div ░░░░▀▄▒▒▒▒▒▒▒▒▒▒▄▄▄▀▒▒▒▒▄▀░░░
        div ░░░░░░▀▄▄▄▄▄▄▀▀▀▒▒▒▒▒▄▄▀░░░░░
        div ░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▀▀░░░░░░░░

= slide 'Решения на предизвикателството' do
    p имаме забележки(да ни се не надява човек)

= slide 'Решения на предизвикателството' do
    annotate:
        if smth == True:
            return True
        else:
            return False

    p.action srsly?
    p.action защо?
    div.action
        annotate:
            return smth

= slide 'Решения на предизвикателството' do
    annotate:
        i = 0
        while i < n:
            ...
            i += 1

    p
        | прекрасна конструкция 
        span.action ако пишем на C

    div.action
        annotate:
            for i in range(n):
                ...

= slide 'Решения на предизвикателството' do
    annotate:
        return bool(count == number and number != 0)

    div.action
        p друга възможност
        annotate:
            bool(int(float(int(str(int(count == number and number != 0))))))

= slide 'Решения на предизвикателството' do
    p някои много гадни имена:
    ul
        li.action cnt
        li.action devisor
        li.action maxi
        li.action sumdel
        li.action delimiter, divider, devider
        li.action i_max_deliter, i_input_number, i_sum_of_delitels, i_possible_delitel
        li.action dev_comb (гребен за developer-и?)

= slide 'Решения на предизвикателството' do
    p малко ми е гадно за is_prefect

= slide 'Решения на предизвикателството' do
    annotate:
        perfect=False
        ...
        if(sum == number):
                perfect = True
        else: 
                pass
        
        return perfect

    p.action 8 spaces for added bonus swag!

= slide 'Решения на предизвикателството' do
    img src="03/allthethings.png"
    p повече от 3(4, ако живота ви зависи от това) нива на влагане са ужасни

= slide 'Решения на предизвикателството' do
    annotate:
         value.__ne__(n)

    p инвестирано е време, за да се потърси как се сравняват числа в python?
    p инвестицията е на загуба

= slide 'Решения на предизвикателството' do
    annotate:
        import math
        def is_perfect( chislo ):
                if not isinstance(chislo,int):
                        return print(False)
                sum=0 
                for x in range(1, math.floor(chislo / 2)+1):
                        if chislo % x == 0:
                                sum+=x
                return print(sum == chislo)

    p ако сме тръгнали, python няма проблем с unicode, дайте да е като хората
    annotate:
        import math
        def is_perfect( число ):
                if not isinstance(число,int):
                        return print(False)
                sum=0 
                for x in range(1, math.floor(число / 2)+1):
                        if число % x == 0:
                                sum+=x
                return print(sum == число)

    p.action 8 spaces for added bonus swag!

= slide 'Решения на предизвикателството' do
    annotate:
        while(something):
            ...

        if(something):
            ...

    p.action малкия проблем е, че пред скобите трябва да има space
    p.action по-сериозния проблем е, че в python не се пишат скоби на такива места

= slide 'Обощение' do
    img.action src='03/sheldon.png'

= slide 'Малко стил' do
    p PEP8! Това е конвенцията за стил на Python. Задължително спазване!
    ul
        li.action Индентация с <b>4</b> интервала за всяко ниво на влаганеи
        li.action Максимално <b>79</b> символа на ред!

        li.action <b>lower_snake_case</b> за имена на функции, методи, променливи, параметри 
        li.action имена на "константи" в <b>UPPER_SNAKE_CASE</b>
        li.action <b>_turn_around, __seriously_turn_around</b> за "частни" ("private")
        li.action използване на запазени думи? 1 подчетавка след името: <b>range_</b>, но..
        li.action <i>по-добре използвайте друго име</i>

        li.action интервал след "," при изброяване и ":" при конструиране на dict:  <b> [1, 2, 3] {1: 2, 2: 4, 13: 26} </b>
        li.action без интервали след (, [, { и след ), ], }:  <b> func(1, 2, 3), [5, 6, 7, 8]</b>
        li.action по един интервал около оператори:  <b> a == b; 3 > 4; "abra" +  "-" + "kadabra"</b> 
        li.action изключение: може да липсват около оператори с по-висок приоритет в подходящ конеткст:  <b> 42 - 6*9</b>
        li.action без интервали, когато задаваме стойност по подразбиране:  <b>	def my_func(a, b, option=True): .. </b>
        li.action и при подаване на именовани параметри при извикване  <b> my_func(option=False, b=13, a=666)</b>
        li.action без скоби около условията на while/for/if/elif/return: <b> while True; return my_result ... </b>

        p
           |Още много от 
           a href="http://legacy.python.org/dev/peps/pep-0008/" източника

= slide 'And now for something completely different' do
    p По същество за колекции

= slide 'Да си подредим данните' do
    p Когато имаме данни, най-логично е да ги слагаме в колекции.
    ul
        li list(a.k.a. array, масив) = подредена последователност от стойности
        li tuple = непроменяема по състав подредена последователност от обекти(~списък, но не съвсем)
        li set = стойности без повтаряне и без подредба(множество в математическия смисъл)
        li dict = ключове/имена, зад които стоят стойности(без подредба)

= slide 'Какво е колекция?' do
    ul
        li.action В Python всички колекциите са итерируеми (iterable)
        li.action Един итерируем обект може да бъде обхождан последователно(поне веднъж)
        li.action Някои могат да бъдат обхождани многократно или непоследователно

= slide 'списъци' do
    annotate:
        nice_things = ['coffee', 'cheese', 'crackers', 'tea']
        for thing in nice_things:
            print('I tend to like ' + thing)

    p можем и просто да ги индексираме
    annotate:
        print(nice_things[1]) # cheese
        print(nice_things[-1]) # tea
        print(nice_things[-3]) # cheese

= slide 'списъци' do
    p Списъците съдържат "указатели" към елементи

    annotate:
        coffee, cheese, crackers, tea = 'coffee', 'cheese', 'crackers', 'tea' # unpacking
        things_i_like = [coffee, cheese, crackers]
        things_you_like = [crackers, coffee, tea]

        things_i_like[0] == things_you_like[1] # True
        things_i_like[0] is things_you_like[1] # True

= slide 'списъци' do
    p Това позволява някои интересни неща
    annotate:
        cheeses = ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto']
        cheeses.append(cheeses)

        cheeses[-1] is cheeses # True
        print(cheeses) # ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto', [...]]

= slide 'списъци(-ception)' do
    annotate:
        cheeses = ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto']
        teas = ['chai', 'earl grey', 'jasmine', 'oolong']

        breakfast = [cheeses, teas]
        print(breakfat[0][1]) # bergkäse

        breakfast[1][2] = ['шкембе', 'люти чушки', 'оцет с чесън']
        print(teas) # ?

    p.action ['chai', 'earl grey', ['шкембе', 'люби чушки', 'оцет с чесън'], 'oolong']

= slide 'range' do
    p range връща итерируемо за интервал от числа
    annotate:
        numbers = range(3)

        for number in numbers:
            print('We can count to ' + numbers)


= slide 'range' do
    p range интервалът може да не започва от нула
    annotate:
        numbers = range(10, 13)

        for number in numbers:
            print('We can count to ' + numbers)

= slide 'tuple' do
    p последователност, n-торка(n-орка), тюпъл
    p като списък, но с постоянен състав

    annotate:
        people = ('Niki', 'Kiro', 'Stefan')
        people[2] # Stefan
        people[1] # Kiro
        people[0] # Niki

        people[1] = 'бобър'

        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: 'tuple' object does not support item assignment

    h2.action кортеж

= slide 'tuple' do
    p последователността от елементи в кортежа не може да се променя, самите елементи може да изменят вътрешната си структура

    annotate:
        change_me = ([1, 2, 3], [4, 5, 6], [7, 8, 9])
        change_me[1][1] = 0
        change_me[2][0] = 'c'

        print(change_me) # ([1, 2, 3], [4, 0, 6], ['c', 8, 9])

= slide 'tuple' do
    p алтернативен синтаксис за кортежи
    annotate:
        people = 'Niki', 'Kiro', 'Stefan'
        people = 'Niki',

        people = ('Niki') # най-вероятно не е каквото очаквате

= slide 'Популярни структури от данни' do
    p Опашка (queue, FIFO buffer) - можете да ползвате списък.
    annotate:
        adjectives = []

        def add_adjective(items):
            adjectives.append(items)

        def get_adjective():
            return adjectives.pop(0)

        add_adjective('Magic')
        add_adjective('Woody Allen')
        add_adjective('Zombie')
        add_adjective('Superhero')

        print(' '.join(adjectives) + ' Jesus!') # Magic Woody Allen Zombie Superhero Jesus!

    p Stack?


= slide 'Влизат collections' do
    ul
        li deque - двупосочни опашки
        li OrderedDict - речник, който помни реда
        li defaultdict - речник със стойност по подразбиране
        li Counter - set, който брои повтарящи се стойности

= slide 'deque' do
    annotate:
        from collections import deque
        adjectives = deque()

        def add_adjective(items):
            adjectives.append(items)

        def get_adjective():
            return adjectives.popleft()

        add_adjective('Komodo Dragon')
        add_adjective('Telepathic')
        add_adjective('Vampire')
        add_adjective('Quantum Hovercraft')

        print(' '.join(adjectives) + ' Jesus') # Komodo Dragon Telepathic Vampire Quantum Hovercraft Jesus

= slide 'sets' do
    p Множества(за всякакви практически цели неразличими от математическата абстракция със същото име)
    annotate:
        favourite_numbers = set()
        favourite_numbers.add(13)
        favourite_numbers.add(73)
        favourite_numbers.add(32)
        favourite_numbers.add(73)
        favourite_numbers.add(1024)
        favourite_numbers.add(73)

        print(favourite_numbers) # {32, 73, 666, 13, 1024}

= slide 'sets' do
    p Множествата са итеруеми и НЕподредени

    annotate:
        for num in favourite_numbers:
            print('I really like the number ' + num)


= slide 'sets' do
    p можем да проверяваме за принадлежност
    annotate:
        73 in favourite_numbers # True

= slide 'sets' do
    p Има синтаксис за създаване на множества(както може би сте се досетили)
    annotate:
        favourite_numbers = {32, 73, 666, 13, 1024}

    p 
        strong {} не е празния set!

= slide 'dict' do
    p Индексите не винаги са достатъчно информативни
    annotate:
        artist_names = {
            'Eddie': 'Vedder',
            'Maynard': 'Keenan',
            'Matthew': 'Bellamy',
            'James': 'LaBrie',
        }

        print('Eddie\'s last names is ' + names['Eddie'])

= slide '{}' do
    p {} е празен речник, по простата причина, речниците са доста по-често използвана структура от множествата

= slide 'dict' do
    p можем да добавяме нови стойности във вече създаден речник
    annotate:
        names['Devin'] = 'Townsend'

        print(names) # {'Devin': 'Townsend', 'Matthew': 'Bellamy', 'Eddie': 'Vedder', 'James': 'LaBrie', 'Maynard': 'Keenan'}

    p речникът също е неподреден

= slide 'кой какви сирена има' do
    annotate:
        data = [ ('John', 'Tilsit'), ('Eric', 'Cheshire'), ('Michael', 'Camembert'),
                 ('Terry', 'Gouda'), ('Terry', 'Port Salut'), ('Michael', 'Edam'),
                 ('Eric', 'Ilchester'), ('John', 'Fynbo') ]

        def cheeses_by_owner(cheeses_data):
            by_owner = {}
            for owner, cheese in cheeses_data: # <- tuple unpacking
                if owner[0] in by_owner:
                    by_owner[owner].append(cheese)
                else:
                    by_owner[owner] = [cheese]

            return by_owner

= slide 'defauldict' do
    annotate:
        from collections import defaultdict
        data = [ ('John', 'Tilsit'), ('Eric', 'Cheshire'), ('Michael', 'Camembert'),
                 ('Terry', 'Gouda'), ('Terry', 'Port Salut'), ('Michael', 'Edam'),
                 ('Eric', 'Ilchester'), ('John', 'Fynbo') ]

        def cheeses_by_owner(cheeses_data):
            by_owner = defaultdict(list)
            for owner, cheese in cheeses_data:
                by_owner[owner].append(chese)

            return by_owner

= slide 'map/filter/reduce' do
    ul
        li.action map(function, iterable) създава колекция от резултатите от прилагането на function върху всеки елемент от iterable
        li.action filter(function, iterable) създава колекция само с елементите, за които function върне True
        li.action
            | reduce(function, iterable) вика function с елементите на колекцията, докато сведе всичко до една стойност (във functools вж.
            a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" тук
            | )

    p.action за любознателните: map и filter са мързеливи

= slide 'Comprehensions' do
    ul
        li
            |Изрази, които 
            em генерират 
            | колекции
        li Елегантен заместител на map и/или filter
        li Колекциите могат да са динамични

= slide 'List comprehension' do
    annotate:
        [израз for променлива in поредица if условие]

        >>> [x * x for x in range(0, 10)]
        [1, 4, 9, 16, 25, 36, 49, 64, 81]

        >>> [x * x for x in range(0, 10) if x % 2]
        [1, 9, 25, 49, 81]

= slide 'List comprehension' do
    p Един list comprehension може да се вложи в друг, защото връща нещо итерируемо
    annotate:
        >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
        [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

= slide 'Generator expression' do
    ul
        li.action Кръгли скоби вместо квадратни
        li.action Като list comprehension, но се изпълнява динамично(lazy evaluation)
        li.action На всяка стъпка итератора оценява условието и израза за следващата стройност

= slide 'Set comprehension' do
    ul
        li Като list comprehension, но с { }

    annotate:
        >>> import math
        >>> {int(math.sqrt(x)) for x in range(1,100)}
        {1, 2, 3, 4, 5, 6, 7, 8, 9}

= slide 'Dict comprehension' do
    annotate:
        >>> {i : chr(65+i) for i in range(10)}
        {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F', 6: 'G', 7: 'H', 8: 'I', 9: 'J'}


= slide 'itertools' do
    annotate:
        >>> import itertools
        >>> help(itertools)
