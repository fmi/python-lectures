= slide 'Предизвикателството' do
  p Всъщност сте се справили доста добре
  p 40 от 53 човека имат 10 минаващи теста
  img.action src="02/not-bad.jpg"

= slide 'Предизвикателството' do
  p Но все пак сте ни оставили малко материал за първите няколко слайда днес

= slide 'Naming things' do

  p Трудно е, определено няма го оспорим
  p За някои неща обаче не е простичко

  p <code>stoynosti</code> и <code>stoynost</code> с нищо не са по-добри от <code>values</code> и <code>value</code>. Даже са откровено по-лош избор.

= slide 'return vs. print' do
  p Молим ви, нека това е първия и единствен път, в който трябва да говорим за това

  div.action
    example:
      def answer():
          return 42

      def antwoord():
          print(42)

      a = answer() # 42
      b = antwoord() # None

= slide 'Един въпрос' do
    p Какво ще изведе този код?

    example:
        foods = ['spam', 'eggs', 'ham']
        things = foods
        things[1] = 'chips'
        print(foods[1])

= slide 'Още един' do
    example:
        my_string = '1234567890'
        >> my_string[10]
    p.action  IndexError: string index out of range

= slide 'И още един..' do
    example:
        my_data = set(range(10))

        for x in my_data:
            print(x)
            break

    p.action Ще изпринти един от елементите, без гаранция кой

= slide 'Последен..' do
    example:
        {}
        set()
        1
        None
        True
        [1, 2, 3]
        (1, 2, 3)
        12.0
        'абвг'
        lambda x: x**0
        print, 5, 6, 7, 8

    p.action Кои от тези са валидни ключове за dict?

    p.action 1, None, True, (1, 2, 3), 12.0, 'абвг', lambda-та и (print, 5, 6, 7 ,8)

= slide 'Излъгах :)' do
    example:
        my_dict = dict('12 34 16'.split() + [(False, False)])
        print(len(my_dict), my_dict[0])


    p.action 3 False

= slide 'Организация на кода' do
  ol
    li Запазете вашето решение във файл с името `solution.py`.
    li Свалете `sample_test.py` в същата директория, в която е решението ви
    li През командния ред на операционната си система отидете във въпросната директория
    li Изпълнете `python3.5 sample_test.py`
    li Ако имате дълбока фундаментална грешка в решението си това ще ви покаже каква е

= slide 'Малко стил' do
    p PEP8! Това е конвенцията за стил на Python. Задължително спазване!
    ul
        li Индентация с <b>4</b> интервала за всяко ниво на влагане
        li Максимално <b>79</b> символа на ред!

        li <b>snake_case</b> за имена на функции, методи, променливи, параметри
        li имена на "константи" в <b>SCREAMING_SNAKE_CASE</b>
        li <b>_turn_around, __seriously_turn_around</b> за "частни"("private")
        li използване на запазени думи? 1 подчертавка след името: <b>range_</b>, но..
        li <i>по-добре използвайте друго име</i>

= slide 'Още малко стил' do
    p PEP8! Това е конвенцията за стил на Python. Задължително спазване!
    ul
        li интервал след "," при изброяване и ":" при конструиране на dict:  <b> [1, 2, 3] {1: 2, 2: 4, 13: 26} </b>
        li без интервали след (, [, { и след ), ], }:  <b> func(1, 2, 3), [5, 6, 7, 8]</b>
        li по един интервал около оператори:  <b> a == b; 3 > 4; "abra" +  "-" + "kadabra"</b>
        li изключение: може да липсват около оператори с по-висок приоритет в подходящ конеткст:  <b> 42 - 6*9</b>
        li без интервали, когато задаваме стойност по подразбиране:  <b>	def my_func(a, b, option=True): .. </b>
        li и при подаване на именовани параметри при извикване  <b> my_func(option=False, b=13, a=666)</b>
        li без скоби около условията на while/for/if/elif/return: <b> while True: ...</b>

    p.action Още много от <a href="https://www.python.org/dev/peps/pep-0008/">източника</a>

= slide 'PEP8' do
  p Никой не е запомнил целия pep8 само с четене
  p Всеки редактор може да бъде конфигуриран, така че да използва pep8, за да проверява кода ви и да се кара когато не правите нещо правилно
  p Научете се как да ползвате добре редактора, който сте си избрали, това е много важно

  example:
    pip install pep8

= slide 'And now for something completely different' do
    p По същество за колекции

= slide 'Да си подредим данните' do
    p Когато имаме данни, най-логично е да ги слагаме в колекции.
    ul
        li list (a.k.a. array, масив) = подредена последователност от стойности
        li tuple = непроменяема по състав подредена последователност от обекти (~списък, но не съвсем)
        li set = стойности без повтаряне и без подредба (множество в математическия смисъл)
        li dict = ключове/имена, зад които стоят стойности (без подредба)

= slide 'Какво е колекция?' do
    ul
        li.action В Python всички колекции са итерируеми (iterable)
        li.action Един итерируем обект може да бъде обхождан последователно (поне веднъж)
        li.action Някои могат да бъдат обхождани многократно или непоследователно

= slide 'списъци' do
    example:
        nice_things = ['coffee', 'cheese', 'crackers', 'tea']
        for thing in nice_things:
            print('I tend to like {}'.format(thing))

    p можем и просто да ги индексираме
    example:
        print(nice_things[1]) # cheese
        print(nice_things[-1]) # tea
        print(nice_things[-3]) # cheese

= slide 'списъци' do
    example:
        cute_animals = ['cat', 'raccoon', 'panda', 'red panda', 'marmot']
        cute_animals[1:3]  # ['raccoon', 'panda']
        cute_animals[-1]  # 'marmot'
        cute_animals[1:-1]  # ['raccoon', 'panda', 'red panda']
        cute_animals[::-1]  # ['marmot', 'red panda', 'panda', 'raccoon', 'cat']
        cute_animals[-1:0:-1]  # ['marmot', 'red panda', 'panda', 'raccoon']
        cute_animals[-1:0:-2]  # ['marmot', 'panda']

= slide 'списъци' do
    p Списъците съдържат "указатели" към елементи

    example:
        coffee, cheese, crackers, tea = 'coffee', 'cheese', 'crackers', 'tea' # unpacking
        things_i_like = [coffee, cheese, crackers]
        things_you_like = [crackers, coffee, tea]

        things_i_like[0] == things_i_like[1] # True
        things_i_like[0] is things_i_like[1] # True

= slide 'списъци' do
    p Това позволява някои интересни неща
    example:
        cheeses = ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto']
        cheeses.append(cheeses)

        cheeses[-1] is cheeses # True
        print(cheeses) # ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto', [...]]

= slide 'списъци(-ception)' do
    example:
        cheeses = ['brie', 'bergkäse', 'kashkaval', 'leipäjuusto']
        teas = ['chai', 'earl grey', 'jasmine', 'oolong']

        breakfast = [cheeses, teas]
        print(breakfast[0][1]) # bergkäse

        breakfast[1][2] = ['шкембе', 'люби чушки', 'оцет с чесън']
        print(teas) # ?

    div.action
        example:
            ['chai', 'earl grey', ['шкембе', 'люби чушки', 'оцет с чесън'], 'oolong']

= slide 'методи на списъци' do
    list:
        `.index(element)` - Индекса на първото срещане на element в списъка или гърми с ValueError
        `.count(element)` - Броят срещания на element в списъка
        `.append(element)` - Добавя element в края на списъка
        `.extend(elements)` - Добавя елементите на elements в списъка (като + ама по-бързо)
        `.sort()` - Сещате се
        ...

= slide 'range' do
    p range връща итерируемо за интервал от числа
    example:
        numbers = range(3)

        for number in numbers:
            print('We can count to ' + str(number))


= slide 'range' do
    p range интервалът може да не започва от нула
    example:
        numbers = range(10, 13)

        for number in numbers:
            print('We can count to ' + str(number))

= slide 'range' do
    p range може и в обратен ред
    example:
        numbers = range(13, 0, -1)

        for number in numbers:
            print('We can count to ' + str(number))

= slide 'tuple' do
    p последователност, n-торка(n-орка), тюпъл
    p като списък, но с постоянен състав

    example:
        people = ('Niki', 'Kiro', 'Genata')
        people[2] # Genata
        people[1] # Kiro
        people[0] # Niki

        people[1] = 'бобър'

        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: 'tuple' object does not support item assignment

    h2.action кортеж

= slide 'tuple' do
    p последователността от елементи в кортежа не може да се променя, самите елементи може да изменят вътрешната си структура

    example:
        change_me = ([1, 2, 3], [4, 5, 6], [7, 8, 9])
        change_me[1][1] = 0
        change_me[2][0] = 'c'

        print(change_me) # ([1, 2, 3], [4, 0, 6], ['c', 8, 9])

= slide 'tuple' do
    p алтернативен синтаксис за кортежи
    example:
        people = 'Niki', 'Kiro', 'Genata'
        people = 'Niki',

        people = ('Niki') # най-вероятно не е каквото очаквате

    p.action Има методите `index` и `count` като на списъците

= slide 'Любопитни работи' do

    p Ако имате n-торка, съдържаща само имена от лявата страна на присвояване, може да постигнете интересни ефекти:

    example:
      (a, b) = 1, 2
      print(a)  # 1

= slide 'Любопитни работи' do

    p Всъщност скобите изобщо не са задължителни

    example:
      a, b = 1, 2
      print(a)  # 1

= slide 'Любопитни работи' do
    p Или

    example:
        numbers = (1, 2, 3)
        a, b, c = numbers

= slide 'Любопитни работи' do
    p Можем да правим и така:
    example:
      a, *b, c = 1, 2, 3, 4, 5
      a = 1
      b = [2, 3, 4]
      c = 5

= slide 'Сравняване на списъци и кортежи' do

    p Сравняват се лексикографски:

    example:
        >>> (1, 2) < (1, 3)
        True
        >>> (1, 2) < (1, 2)
        False
        >>> (1, 2) < (1, 2, 3)
        True
        >>> [1, 2] < [1, 3]
        True
        >>> (1, 2) < [1, 3] # tuple vs. list
        # поражда грешка:
        #    TypeError: unorderable types: tuple() < list()

= slide 'Популярни структури от данни' do
    p Опашка (queue, FIFO buffer) - можете да ползвате списък.
    example:
        adjectives = []

        def add_adjective(items):
            adjectives.append(items)

        def get_adjective():
            return adjectives.pop(0)

        add_adjective('Magic')
        add_adjective('Woody Allen')
        add_adjective('Zombie')
        add_adjective('Superhero')

        print(' '.join(adjectives) + ' Jesus!') # Magic Woody Allen Zombie Superhero Jesus!

    p Stack?

= slide 'sets' do
    p Множества(за всякакви практически цели неразличими от математическата абстракция със същото име)
    example:
        favourite_numbers = set()
        favourite_numbers.add(13)
        favourite_numbers.add(73)
        favourite_numbers.add(32)
        favourite_numbers.add(73)
        favourite_numbers.add(1024)
        favourite_numbers.add(73)

        print(favourite_numbers) # {32, 73, 666, 13, 1024}

= slide 'sets' do
    p Множествата са итеруеми и НЕподредени

    example:
        for num in favourite_numbers:
            print('I really like the number ' + str(num))


= slide 'sets' do
    p можем да проверяваме за принадлежност
    example:
        73 in favourite_numbers # True

= slide 'sets' do
    p Има синтаксис за създаване на множества(както може би сте се досетили)
    example:
        favourite_numbers = {32, 73, 666, 13, 1024}

    p
        strong {} не е празния set!

= slide 'Операции с множества' do

  example:
      >>> {1, 2, 3} | {2, 3, 4}
      {1, 2, 3, 4}
      >>> {1, 2, 3} & {2, 3, 4}
      {2, 3}
      >>> {1, 2, 3} - {2, 3, 4}
      {1}
      >>> {1, 2, 3} ^ {2, 3, 4}
      {1, 4}
      >>> {1, 2, 3} < {2, 3, 4}
      False
      >>> {2, 3} < {2, 3, 4} # < - подмножество
      True
      >>> {2, 3} == {2.0, 3}
      True
      >>> {1, 2}.isdisjoint({3, 4})
      True

= slide 'dict' do
    p Индексите не винаги са достатъчно информативни
    example:
        artist_names = {
            'Eddie': 'Vedder',
            'Maynard': 'Keenan',
            'Matthew': 'Bellamy',
            'James': 'LaBrie',
        }

        print('Eddie\'s last names is ' + artist_names['Eddie'])

= slide '{}' do
    p {} е празен речник, по простата причина, речниците са доста по-често използвана структура от множествата

= slide 'dict' do
    p можем да добавяме нови стойности във вече създаден речник
    example:
        names['Devin'] = 'Townsend'

        print(names) # {'Devin': 'Townsend', 'Matthew': 'Bellamy',
                     #  'Eddie': 'Vedder', 'James': 'LaBrie', 'Maynard': 'Keenan'}

    p речникът също е неподреден

= slide 'Три други начина за създване на речник' do

    p Чрез наименовани параметри към конструктора (не питайте):

    example:
        >>> dict(france="Paris", italy="Rome")
        {'italy': 'Rome', 'france': 'Paris'}

    p Чрез списък от двойки

    example:
        >>> dict([('One', 'I'), ('Two', 'II')])
        {'Two': 'II', 'One': 'I'}

    p Чрез списък от ключове и стойност по подразбиране

    example:
        >>> dict.fromkeys([1, 2, 3], 'Unknown')
        {1: 'Unknown', 2: 'Unknown', 3: 'Unknown'}

= slide 'Речници и хеш функции' do
  list:
      Функция от вид: обект → число
      Не е нужно да е инективна
      Ако два обекта са еднакви по стойност, те имат еднакъв хеш
      Възможно е различни обекти да имат еднакъв хеш
      За да работят речниците и множествата, ключовете трябва да могат да се сравняват с ==
      Добре е това да става по смислен начин
      Желателно е ключовете да са immutable

= slide 'кой какви сирена има' do
    example:
        data = [('John', 'Tilsit'), ('Eric', 'Cheshire'), ('Michael', 'Camembert'),
                ('Terry', 'Gouda'), ('Terry', 'Port Salut'), ('Michael', 'Edam'),
                ('Eric', 'Ilchester'), ('John', 'Fynbo')]

        def cheeses_by_owner(cheeses_data):
            by_owner = {}
            for owner, cheese in cheeses_data: # <- tuple unpacking
                if owner in by_owner:
                    by_owner[owner].append(cheese)
                else:
                    by_owner[owner] = [cheese]

            return by_owner

= slide 'map/filter/reduce/all/any' do
    ul
        li.action map(function, iterable) създава колекция от резултатите от прилагането на function върху всеки елемент от iterable
        li.action filter(function, iterable) създава колекция само с елементите, за които function върне True
        li.action
            | reduce(function, iterable) вика function с елементите на колекцията, докато сведе всичко до една стойност (във functools вж.
            a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" тук
            | )
        li.action all(iterable) всички елементи се оценяват на истина
        li.action any(iterable) поне един от елементите се оценява на истина

    p.action за любознателните: map и filter са мързеливи

= slide 'Comprehensions' do
    ul
        li Изрази, които <em>генерират</em> колекции
        li Елегантен заместител на map и/или filter
        li Колекциите могат да са динамични

= slide 'List comprehension' do
    example:
        [израз for променлива in поредица if условие]

        >>> [x * x for x in range(0, 10)]
        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

        >>> [x * x for x in range(0, 10) if x % 2]
        [1, 9, 25, 49, 81]

= slide 'List comprehension' do
    p Един list comprehension може да се вложи в друг, защото връща нещо итерируемо
    example:
        >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
        [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

= slide 'Generator expression' do
    ul
        li.action Кръгли скоби вместо квадратни
        li.action Като list comprehension, но се изпълнява динамично (lazy evaluation)
        li.action На всяка стъпка итератора оценява условието и израза за следващата стойност

= slide 'Set comprehension' do
    ul
        li Като list comprehension, но с { }

    example:
        >>> import math
        >>> {int(math.sqrt(x)) for x in range(1,100)}
        {1, 2, 3, 4, 5, 6, 7, 8, 9}

= slide 'Dict comprehension' do
    example:
        >>> {i: chr(65+i) for i in range(10)}
        {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F', 6: 'G', 7: 'H', 8: 'I', 9: 'J'}

= slide 'Влизат collections' do
    ul
        li deque - двупосочни опашки
        li OrderedDict - речник, който помни реда
        li defaultdict - речник със стойност по подразбиране
        li Counter - речник, който брои повтарящи се стойности
        li namedtuple - кортеж с именовани полета

= slide 'deque' do
    example:
        from collections import deque

        adjectives = deque()


        def add_adjective(items):
            adjectives.append(items)


        def get_adjective():
            return adjectives.popleft()

        add_adjective('Komodo Dragon')
        add_adjective('Telepathic')
        add_adjective('Vampire')
        add_adjective('Quantum Hovercraft')

        print(' '.join(adjectives) + ' Jesus') # Komodo Dragon Telepathic Vampire Quantum Hovercraft Jesus

= slide 'defaultdict' do
    example:
        from collections import defaultdict


        data = [('John', 'Tilsit'), ('Eric', 'Cheshire'), ('Michael', 'Camembert'),
                 ('Terry', 'Gouda'), ('Terry', 'Port Salut'), ('Michael', 'Edam'),
                 ('Eric', 'Ilchester'), ('John', 'Fynbo')]


        def cheeses_by_owner(cheeses_data):
            by_owner = defaultdict(list)
            for owner, cheese in cheeses_data:
                by_owner[owner].append(cheese)

            return by_owner


= slide 'Още малко стил' do
    list:
      Обърнахте ли внимание, че ползвахме `cute_animals`, а не `cute_animal_list`?
      Използвайте вградените литерали за да създавате колекции
