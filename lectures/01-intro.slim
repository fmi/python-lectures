= slide 'Къде отива кода?' do
    list:
        Код се пише в `.py` файлове (например `gameoflife.py`).
        Изпълнява се с python `gameoflife.py`
        Можем да пишем код интерактивно като пуснем `python` без аргументи.

= slide 'Python е предсказуем' do
    p Когато не сте сигурни, просто пробвайте.
    example:
      $ python
      >>> 5 + 10
      15
      >>> a = 5
      >>> b = a + 10
      >>> print(b)
      15
      >>> a * 2
      10
      >>> a ** 2
      25
      >>> "hello" + ', ' + "world"
      "hello, world"

= slide 'Първа помощ' do
    p В интерактивната конзола, <code>help()</code> показва документацията на всяка функция, клас или тип.
    example:
       >>> help(str)
       >>> help(5)
       >>> help(SomeClass)
       >>> help(some_function)

= slide 'Един ред код' do
    example:
       my_var = 'spam'.upper()
       print(my_var) # SPAM
    list:
        Съдържа един израз, никога не завършва с `;`
        Всичко след `#` е коментар


= slide 'Типове: int' do
    list:
        Цели числа, положителни и отрицателни
        Стандартни операции: `+`, `-`, `*`, `/`, '%', `**` (степенуване)
        Без максимален размер
        Пробвай `2 ** 4 ** 8` (степенуване)

= slide 'Типове: str' do
    example:
       >>> "hello".upper()
       "HELLO"
       >>> len("абвгдеж")
       7
       >>> "hello"[1]
       "e"
       >>> help(str)
    list:
        Текстови низове с произволна дължина
        Единични или двойни кавички
        Unicode навсякъде
        Поддържат `\n`, `\t` и пр.

= slide 'Типове: bool' do
    list:
        `True` и `False`, не забравяйте главните букви

= slide 'Типове: None' do
    list:
        Като `null` в другите езици.
        Когато една функция не върне нищо, тя връща `None`.

= slide 'Типове' do
    example:
      >>> type(5.5)
      <class 'float'>
      >>> type(type)
      <class 'type'>
      >>> type(type(type(type)))
      <class 'type'>
    list:
        Всяка стойност има тип, включително функциите.
        Всяка стойност е обект и има клас, включително функциите.
        Всичко е обект, включително функциите и типовете!
        Можем да видим типа на нещо с `type()`

= slide 'Имена' do
    ul
        li Можем да дадем име на стойност и получаваме променлива: <code>velocity = distance / 60</code>
        li  Динамичен език - стойностите имат тип, но имената - не.
    example:
       а = 5
       type(a) # <class 'int'>
       a = 'test'
       type(a) # <class 'str'>

= slide 'Имена в картинки' do
    img src='01/name_assignment_1.png'
    img src='01/name_assignment_2.png'
    img src='01/name_assignment_3.png'

= slide 'Структури от данни' do
    list:
        Списък - `list`
        Речник - `dict`
        Tuple - `tuple`
        Множество - `set`
        Както винаги - `help(dict)`

= slide 'Списъци' do
    example:
       my_list = []
       my_list = list()
    list:
        Списък = `list` = масив = array
        Mutable и без фиксирана дължина
        Бързи за търсене по индекс, бавни за търсене по стойност
        Гарантиран ред
        Могат да се смесват типове

= slide 'Списъци' do
    example:
       my_list = []
       my_list.append('word')
       my_list.append(5)
       my_list.append(False)

       my_list[1] == 5

       my_other_list = ['foo', 'bar', 'quux']
       len(my_other_list) # 3
       del my_other_list[1]

       print(my_other_list) # ['foo', 'quux']

       'foo' in my_other_list # True
       False in my_list # True

= slide 'Речник (dict)' do
    example:
       ages = {'Кай': 2, 'Бобо': 3}
       ages['Йоан'] = 26
       ages['Стефан'] = 18
       ages['Кирил'] = 35
       ages['Николай'] = 28

       print(ages['Кирил']) # 35
       'Николай' in ages # True

       ages.get('Георги') # None
       ages.get('Георги', 'няма такъв') # няма такъв
    list:
        Речник = `dict` = hashtable = associative array
        Реда не е гарантиран
        Асоциира ключ със стойност

= slide 'tuple' do
    example:
       >>> args = (9.8, 3.14, 2.71)
       >>> args[2]
       2.71
       >>> args[1] = 22/7
       Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
       TypeError: 'tuple' object does not support item assignment
    list:
        `tuple` = кортеж = n-торка = списък, който не може да бъде променян
        Гарантиран ред
        Ползват за да подадете или върнете няколко стойности от функция, когато специален клас би бил твърде много
        Tuple от един елемент - със запетайка на края: ('Your friends will never love you.',)
        Може и без скобите

= slide 'Структури от данни: set' do
    example:
       >>> unique_numbers = {2, 3, 5, 6}
       >>> unique_numbers
       {2, 3, 5, 6}
       >>> unique_numbers.add(5)
       >>> unique_numbers
       {2, 3, 5, 6}
       >>> unique_numbers.remove(5)
       >>> unique_numbers
       {2, 3, 6}
       >>> my_list = [5, 1, 6, 6, 2, 3, 5, 5]
       >>> set(my_list)
       {1, 2, 3, 5, 6}
    list:
        `set` = множество = списък без повтарящи се елементи
        Редът не е гарантиран

= slide 'Mutable vs immutable' do
    annotate:
       a = 5
       a += 2
       a # =>
    list:
        Immutable са стойностите, които не могат да бъдат променяни.
        Този код не променя стойноста на `5`, а кара `а` да сочи към друга стойност - `7`.
        Immutable са числа, низове, `tuple`s, `True`, `False`, `None`, дата/час (`datetime`).

= slide 'Mutable vs immutable (2)' do
    annotate:
       a = [1, 2, 3]
       a.append(4)
       a # =>
    list:
        Този код променя списъка, към който сочи `a`. Списъците са mutable.
        Всичко останало е mutable.
        Като ключ на `dict` или елемент на `set` могат да се ползват само immutable стойности.

= slide 'Контролни структури' do
    list:
        `if` .. `elif` .. `else`
        `while`
        `for`

= slide 'if' do
    example:
       if a == 5:
           print("a is five")
       elif a == 3 and not b == 2:
           print("a is three, b is not two")
       else:
           print("a is something else")
    list:
        Точно каквото очаквахте.
        Не слагайте скоби около условията.
        `and` и `or` и `not` вместо `&&`, `||`, `!`

= slide 'if' do
    p Булеви тестове:
    example:
       a = True
       if a:
           print("a is True")

       if not a:
           print("a is not True")

= slide 'if' do
    p тестове за принадлежност:
    example:
        my_list = [1, 2, 3, 4]

        if 1 in my_list:
            print('1 is in my list')

        if 5 not in my_list:
            print('5 is not in my list')

= slide 'Индентация' do
    list:
        Къде са къдравите скоби?!
        Всеки вложен блок код (тяло на `if`, тяло на функция, и т.н.) се определя с индентацията му спрямо предишния блок.
        Всеки вложен блок започва само след двуеточие в края на предишния ред.
        Блокът свършва, когато се върнете към предишната индентация.
        4 празни места = нов блок. Не 2, не 3, не табулация.
        Настройте редактора си да слага 4 празни места когато натиснете Tab.

= slide 'while' do
    example:
       while a > 5:
           a -= 1
           print("a is {}".format(a))

= slide 'for' do
    example:
       primes = [3, 5, 7, 11]
       for e in primes:
           print(e ** 2) # 9 25 49 121

       people = {'bob': 25, 'john': 22, 'mitt': 56}
       for name, age in people.items():
           print("{} is {} years old".format(name, age))
           # bob is 25 years old
           # john is 22 years old
           # ...
    list:
        `for` е като `foreach` в другите езици
        Не увеличава индекси, а обхожда структури от данни

= slide 'for като в C' do
    example:
       for i in range(0, 20):
           print(i)
           # 0 1 2 3 4 5 6 .. 19

       for i in range(0, 20, 3):
           print(i)
           # 0 3 6 9 12 15 18

= slide 'Може и наобратно' do
    example:
       for i in range(20, 0, -1):
           print(i)
           # 20 19 18 17 16 15 .. 1

       for i in range(20, 0, -3):
           print(i)
           # 20 17 14 11 8 5 2

= slide 'break и continue' do
    list:
        Работят както очаквате в `for` и `while`.
        Афектират само най-вътрешния цикъл.

= slide 'switch/case' do
    p Няма.

= slide 'Функции' do
    example:
       def say_hello(name, from):
           return "Hello, {}! -- {}".format(name, from)
    list:
        Функцията приема аргументи
        Функцията може да върне нещо с `return`, иначе автоматично се връща `None`
        Както очакваме, не се описват типовете на аргументите, нито типа на резултата

= slide 'Аргументи на функции' do
    example:
       def multiply(a, b=2):
           return a * b

       multiply(5) # 10
       multiply(5, 10) # 50

       def is_pythagorean(a=2, b=3, c=4):
           return a * a + b * b == c * c

       is_pythagorean(b=5) # a = 2, c = 4
       is_pythagorean(1, c=3) # a = 1, b = 3

= slide 'Променливи аргументи' do
    example:
       def varfunc(some_arg, *args, **kwargs):
           #...

       varfunc('hello', 1, 2, 3, name='Bob', age=12)
           # some_arg == 'hello'
           # args = (1, 2, 3)
           # kwargs = {'name': 'Bob', 'age': 12}

    list:
        Функциите могат да приемат произволен брой аргументи
        Позиционните аргументи (тези без име) отиват в `args`(`tuple` от агументи)
        Именуваните аргументи отиват в `kwargs`(`dict` от имена на аргументи и съответните им стойности)
        Имената `args` и `kwargs` могат да се променят, но това е конвенция, която не трябва да нарушавате
